<link rel="stylesheet" href="/admin/content_css/invoice-view.css">

<div class="content-wrapper invoice-view-page">
    <div class="invoice-header">
        <button class="btn-back" type="button" onclick="window.userSpaRouter ? window.userSpaRouter.navigate('bills', true) : history.back()">
            <span data-i18n="user_invoice_back_to_list">← К списку счетов</span>
        </button>
        <h1>
            <span data-i18n="user_invoice_title_prefix">Счёт:</span>
            <span id="invoiceNumber">—</span>
        </h1>
        <div class="d-flex align-items-center gap-2">
            <button class="btn-outline-secondary invoice-pdf-btn" type="button" id="pdfBtn">
                PDF
            </button>
            <button class="btn btn-primary invoice-pay-btn" type="button" id="payBtn" data-i18n="user_invoice_pay_btn">
                Оплатить
            </button>
        </div>
    </div>

    <!-- Краткая информация по счёту -->
    <div class="invoice-summary user-invoice-summary">
        <div class="invoice-summary-item">
            <label data-i18n="user_invoice_house_label">Дом</label>
            <div class="value" id="invoiceHouse">—</div>
        </div>
        <div class="invoice-summary-item">
            <label data-i18n="user_invoice_period_label">Период</label>
            <div class="value" id="invoicePeriod">—</div>
        </div>
        <div class="invoice-summary-item">
            <label data-i18n="user_invoice_status_label">Статус</label>
            <div class="value" id="invoiceStatus">
                <span class="user-bill-status">—</span>
            </div>
        </div>
        <div class="invoice-summary-item">
            <label data-i18n="user_invoice_due_date_label">Срок оплаты</label>
            <div class="value" id="invoiceDueDate">—</div>
        </div>
        <div class="invoice-summary-item">
            <label data-i18n="user_invoice_total_label">Итого</label>
            <div class="value total" id="invoiceTotal">0.00</div>
        </div>
    </div>

    <!-- Оплаты по счёту -->
    <div class="payments-section user-invoice-payments">
        <h3 data-i18n="user_invoice_payments_title">Оплаты по счёту</h3>
        <table class="line-items-table">
            <thead>
                <tr>
                    <th data-i18n="user_invoice_payments_th_date">Дата</th>
                    <th data-i18n="user_invoice_payments_th_method">Метод</th>
                    <th data-i18n="user_invoice_payments_th_amount">Сумма</th>
                    <th data-i18n="user_invoice_payments_th_comment">Комментарий</th>
                </tr>
            </thead>
            <tbody id="paymentsTableBody">
                <tr><td colspan="4" class="text-center text-muted">Загрузка...</td></tr>
            </tbody>
        </table>
        <div class="payments-summary" id="paymentsSummary">
            <span>Оплачено: <strong>0.00</strong> · Остаток: <strong>0.00</strong> из <strong>0.00</strong></span>
        </div>
    </div>

    <!-- Позиции счёта -->
    <div class="user-invoice-items">
        <h3 data-i18n="user_invoice_items_title">Описание</h3>
        <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 12px; padding: 20px; overflow-x: auto;">
            <table class="line-items-table">
                <thead>
                    <tr>
                        <th data-i18n="user_invoice_items_th_description">Описание</th>
                        <th data-i18n="user_invoice_items_th_consumed">Израсходовано</th>
                        <th data-i18n="user_invoice_items_th_charged">Начислено</th>
                        <th data-i18n="user_invoice_items_th_vat">НДС</th>
                        <th data-i18n="user_invoice_items_th_total">Итого</th>
                        <th>Статус</th>
                    </tr>
                </thead>
                <tbody id="invoiceItemsBody">
                    <tr><td colspan="6" class="text-center text-muted">Загрузка...</td></tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

<script>
    (function() {
        'use strict';
        const API_BASE_URL = window.API_BASE_URL || window.BACKEND_API_BASE || 'http://localhost:8000';
        
        // Get invoice ID from sessionStorage or URL
        let currentInvoiceId = null;
        const storedId = sessionStorage.getItem('currentInvoiceId');
        if (storedId) {
            currentInvoiceId = parseInt(storedId);
        }
        
        if (!currentInvoiceId) {
            // Try to get from URL params
            const urlParams = new URLSearchParams(window.location.search);
            const invoiceId = urlParams.get('id') || urlParams.get('invoice_id');
            if (invoiceId) {
                currentInvoiceId = parseInt(invoiceId);
            }
        }
        
        if (!currentInvoiceId) {
            document.querySelector('.content-wrapper').innerHTML = 
                '<div class="text-center text-danger p-4">Ошибка: не найден ID счета. Пожалуйста, вернитесь к списку счетов.</div>';
            return;
        }
        
        // Store invoice ID globally for print page access
        window.currentInvoiceId = currentInvoiceId;
        
        // Load invoice data from backend
        async function loadInvoiceData() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/resident/invoice/${currentInvoiceId}`, {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        window.location.href = '/login.html';
                        return;
                    }
                    if (response.status === 403 || response.status === 404) {
                        throw new Error('Счёт не найден или у вас нет доступа');
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                renderInvoice(data);
            } catch (error) {
                console.error('Error loading invoice:', error);
                document.querySelector('.content-wrapper').innerHTML = 
                    `<div class="text-center text-danger p-4">Не удалось загрузить данные: ${error.message}</div>`;
            }
        }

        // Render invoice data
        function renderInvoice(invoice) {
            // Update header
            const invoiceNumberEl = document.getElementById('invoiceNumber');
            if (invoiceNumberEl) {
                invoiceNumberEl.textContent = invoice.number || `#${invoice.id}`;
            }
            
            // Update PDF button
            const pdfBtn = document.getElementById('pdfBtn');
            if (pdfBtn) {
                pdfBtn.onclick = () => {
                    // Store invoice ID in multiple ways for print page
                    sessionStorage.setItem('printInvoiceId', invoice.id.toString());
                    sessionStorage.setItem('currentInvoiceId', invoice.id.toString());
                    // Also pass as URL parameter for reliability
                    window.open(`/user/invoice-print.html?id=${invoice.id}`, '_blank', 'noopener');
                };
            }

            // Update Pay button
            const payBtn = document.getElementById('payBtn');
            if (payBtn) {
                const remaining = (typeof invoice.remaining_amount === 'number')
                    ? invoice.remaining_amount
                    : (invoice.amount_total || 0);
                if (remaining <= 0) {
                    payBtn.disabled = true;
                    payBtn.style.opacity = '0.6';
                    payBtn.style.cursor = 'not-allowed';
                } else {
                    payBtn.disabled = false;
                    payBtn.style.opacity = '';
                    payBtn.style.cursor = '';
                    payBtn.onclick = () => {
                        try {
                            sessionStorage.setItem('paymentScope', 'invoice');
                            sessionStorage.setItem('paymentAmount', String(remaining));
                            sessionStorage.setItem('paymentScopeLabel', window.i18n?.translate?.('payment_invoice_payment', localStorage.getItem('language') || 'ru') || 'Оплата счёта');
                            sessionStorage.setItem('paymentTimestamp', String(Date.now()));
                            if (invoice.resident_code) {
                                sessionStorage.setItem('paymentResidentCode', invoice.resident_code);
                            }
                            if (invoice.resident_id) {
                                sessionStorage.setItem('paymentResidentId', String(invoice.resident_id));
                            }
                            sessionStorage.setItem('paymentInvoiceId', String(invoice.id));
                        } catch (e) {
                            console.warn('Failed to store payment session data', e);
                        }

                        if (window.userSpaRouter && typeof window.userSpaRouter.navigate === 'function') {
                            window.userSpaRouter.navigate('report', true);
                        } else {
                            window.location.href = '/user/dashboard.html#report';
                        }
                    };
                }
            }
            
            // Update summary
            const houseEl = document.getElementById('invoiceHouse');
            if (houseEl) houseEl.textContent = invoice.resident_code || '—';
            
            const periodEl = document.getElementById('invoicePeriod');
            if (periodEl) {
                const lang = localStorage.getItem('language') || 'ru';
                const locale = lang === 'az' ? 'az-AZ' : lang === 'en' ? 'en-US' : 'ru-RU';
                const monthKeys = [
                    'month_january', 'month_february', 'month_march', 'month_april',
                    'month_may', 'month_june', 'month_july', 'month_august',
                    'month_september', 'month_october', 'month_november', 'month_december'
                ];
                const monthName = window.i18n?.translate?.(monthKeys[invoice.period_month - 1], lang) ||
                    ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
                     'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'][invoice.period_month - 1];
                let periodText = `${monthName} ${invoice.period_year}`;
                if (invoice.period_dates && invoice.period_dates.from && invoice.period_dates.to) {
                    try {
                        const fromDate = new Date(invoice.period_dates.from);
                        const toDate = new Date(invoice.period_dates.to);
                        // Проверяем, что даты валидны
                        if (!isNaN(fromDate.getTime()) && !isNaN(toDate.getTime())) {
                            periodText = `${fromDate.toLocaleDateString(locale)} - ${toDate.toLocaleDateString(locale)}`;
                        } else {
                            // Если даты невалидны, используем исходные строки или fallback
                            periodText = `${invoice.period_dates.from} - ${invoice.period_dates.to}`;
                        }
                    } catch (e) {
                        // В случае ошибки используем исходные строки или fallback
                    periodText = `${invoice.period_dates.from} - ${invoice.period_dates.to}`;
                    }
                } else if (invoice.period_dates && invoice.period_dates.to) {
                    try {
                        const toDate = new Date(invoice.period_dates.to);
                        if (!isNaN(toDate.getTime())) {
                            periodText = toDate.toLocaleDateString(locale);
                        } else {
                            periodText = invoice.period_dates.to;
                        }
                    } catch (e) {
                    periodText = invoice.period_dates.to;
                    }
                }
                periodEl.textContent = periodText;
                periodEl.dataset.periodMonth = invoice.period_month;
                periodEl.dataset.periodYear = invoice.period_year;
            }
            
            const statusEl = document.getElementById('invoiceStatus');
            if (statusEl) {
                const lang = localStorage.getItem('language') || 'ru';
                const statusClass = getStatusClass(invoice.status);
                const statusKey = `status_${invoice.status.toLowerCase()}`;
                const statusText = window.i18n?.translate?.(statusKey, lang) || invoice.status;
                statusEl.innerHTML = `<span class="user-bill-status ${statusClass}" data-status="${invoice.status}">${statusText}</span>`;
            }
            
            const dueDateEl = document.getElementById('invoiceDueDate');
            if (dueDateEl) {
                const lang = localStorage.getItem('language') || 'ru';
                const locale = lang === 'az' ? 'az-AZ' : lang === 'en' ? 'en-US' : 'ru-RU';
                dueDateEl.textContent = invoice.due_date 
                    ? new Date(invoice.due_date).toLocaleDateString(locale)
                    : '—';
                if (invoice.due_date) {
                    dueDateEl.dataset.dueDate = invoice.due_date;
                }
            }
            
            const totalEl = document.getElementById('invoiceTotal');
            if (totalEl) {
                totalEl.textContent = formatCurrency(invoice.amount_total);
            }
            
            // Render payments
            renderPayments(invoice.payments || [], invoice);
            
            // Render invoice lines
            renderInvoiceLines(invoice.lines || [], invoice.amount_total);
        }

        // Translate payment comment (make it globally available)
        window.translatePaymentComment = function translatePaymentComment(comment, lang) {
            if (!comment || comment === '—') return comment;
            
            // Проверяем, что язык передан корректно
            if (!lang) {
                lang = localStorage.getItem('language') || 'ru';
            }
            
            // Паттерны для распознавания комментариев (распознаем на любом языке, но переводим на текущий)
            const patterns = [
                {
                    // "Оплата новой картой ****4567" или "Payment with new card ****4567" или "Yeni kartla ödəniş ****4567"
                    regex: /^(?:Оплата новой картой|Payment with new card|Yeni kartla ödəniş)\s+\*\*\*\*(\d+)$/i,
                    format: (match, last4) => {
                        const template = window.translations?.[lang]?.payment_comment_new_card || 
                                       window.translations?.ru?.payment_comment_new_card || 
                                       'Оплата новой картой ****{last4}';
                        return template.replace('{last4}', last4);
                    }
                },
                {
                    // "Списание из аванса Royal Park Pass" или "Deduction from Royal Park Pass advance" или "Royal Park Pass avansından çıxarış"
                    regex: /^(?:Списание из аванса|Deduction from|Royal Park Pass avansından çıxarış).*Royal Park Pass/i,
                    format: () => {
                        return window.translations?.[lang]?.payment_comment_advance || 
                               window.translations?.ru?.payment_comment_advance || 
                               'Списание из аванса Royal Park Pass';
                    }
                },
                {
                    // "Оплата картой MasterCard ****4567" или "Payment with MasterCard ****4567 card" или "MasterCard ****4567 kartı ilə ödəniş"
                    regex: /^(?:Оплата картой|Payment with|kartı ilə ödəniş)\s+([A-Za-z\s]+?)\s+\*\*\*\*(\d+)/i,
                    format: (match, brand, last4) => {
                        const suffix = `****${last4}`;
                        const template = window.translations?.[lang]?.payment_comment_saved_card || 
                                       window.translations?.ru?.payment_comment_saved_card || 
                                       'Оплата картой {brand} {suffix}';
                        return template.replace('{brand}', brand.trim()).replace('{suffix}', suffix);
                    }
                },
                {
                    // "Онлайн-оплата" или "Online payment" или "Onlayn ödəniş"
                    regex: /^(?:Онлайн-оплата|Online payment|Onlayn ödəniş)$/i,
                    format: () => {
                        return window.translations?.[lang]?.payment_comment_online || 
                               window.translations?.ru?.payment_comment_online || 
                               'Онлайн-оплата';
                    }
                }
            ];
            
            // Пробуем найти подходящий паттерн
            for (const pattern of patterns) {
                const match = comment.match(pattern.regex);
                if (match) {
                    const translated = pattern.format(match, ...match.slice(1));
                    return translated;
                }
            }
            
            // Если паттерн не найден, возвращаем оригинал
            return comment;
        }

        // Render payments table
        function renderPayments(payments, invoice) {
            const tbody = document.getElementById('paymentsTableBody');
            if (!tbody) return;
            
            const lang = localStorage.getItem('language') || 'ru';
            
            if (payments.length === 0) {
                let emptyText = 'Оплаты по этому счёту отсутствуют.';
                if (window.i18n && window.i18n.translate) {
                    emptyText = window.i18n.translate('invoice_payments_empty', lang);
                    // Если вернулся сам ключ, значит перевод не найден - используем fallback
                    if (emptyText === 'invoice_payments_empty') {
                        emptyText = 'Оплаты по этому счёту отсутствуют.';
                    }
                }
                tbody.innerHTML = `<tr><td colspan="4" class="text-center text-muted" data-i18n-empty="invoice_payments_empty">${emptyText}</td></tr>`;
            } else {
                tbody.innerHTML = payments.map(p => {
                    // Определяем метод оплаты
                    let methodDisplay = p.method || '—';
                    let commentDisplay = p.comment || '—';
                    
                    // Проверка 1: Если метод явно "ADVANCE"
                    if (p.method === 'ADVANCE') {
                        methodDisplay = window.i18n ? window.i18n.translate('user_invoice_payment_method_advance', lang) : 'Аванс';
                        if (commentDisplay === '—' || !commentDisplay) {
                            commentDisplay = 'Royal Park Pass';
                        } else {
                            // Переводим комментарий
                            commentDisplay = translatePaymentComment(commentDisplay, lang);
                        }
                    }
                    // Проверка 2: Если в reference есть "ADVANCE" (дополнительная защита)
                    else if (p.reference && p.reference.includes('ADVANCE')) {
                        methodDisplay = window.i18n ? window.i18n.translate('user_invoice_payment_method_advance', lang) : 'Аванс';
                        commentDisplay = translatePaymentComment(commentDisplay, lang) || 'Royal Park Pass';
                    } else {
                        // Переводим комментарий для обычных платежей
                        commentDisplay = translatePaymentComment(commentDisplay, lang);
                    }
                    
                    // Сохраняем оригинальный комментарий для последующего перевода
                    const originalComment = p.comment || '—';
                    
                    return `
                        <tr>
                            <td>${formatDateTime(p.date || p.received_at)}</td>
                            <td>${methodDisplay}</td>
                            <td>${formatCurrency(p.amount)}</td>
                            <td data-original-comment="${originalComment.replace(/"/g, '&quot;')}">${commentDisplay}</td>
                        </tr>
                    `;
                }).join('');
            }
            
            // Update payments summary
            const summaryEl = document.getElementById('paymentsSummary');
            if (summaryEl) {
                const lang = localStorage.getItem('language') || 'ru';
                const summaryTemplate = window.i18n?.translate?.('user_invoice_payments_summary', lang) || 'Оплачено: {paid} · Остаток: {remaining} из {total}';
                const paidFormatted = formatCurrency(invoice.paid_amount);
                const remainingFormatted = formatCurrency(invoice.remaining_amount);
                const totalFormatted = formatCurrency(invoice.amount_total);
                const summaryText = summaryTemplate
                    .replace('{paid}', `<strong>${paidFormatted}</strong>`)
                    .replace('{remaining}', `<strong>${remainingFormatted}</strong>`)
                    .replace('{total}', `<strong>${totalFormatted}</strong>`);
                summaryEl.innerHTML = `<span data-paid-amount="${invoice.paid_amount}" data-remaining-amount="${invoice.remaining_amount}" data-total-amount="${invoice.amount_total}">${summaryText}</span>`;
            }
        }

        // Translate service description
        function translateServiceDescription(description, lang) {
            if (!description) return '—';
            
            // Паттерны для распознавания типов услуг
            const patterns = [
                {
                    regex: /^Электричество\s+([\d.]+)\s*кВт·ч$/i,
                    serviceKey: 'meter_electricity',
                    unitKey: 'user_unit_kwh',
                    format: (amount, service, unit) => `${service} ${amount} ${unit}`
                },
                {
                    regex: /^Вода\s+([\d.]+)\s*м³$/i,
                    serviceKey: 'meter_cold_water',
                    unitKey: 'user_unit_m3',
                    format: (amount, service, unit) => {
                        // Для "Вода" используем простой перевод
                        let waterText = 'Вода';
                        if (lang === 'az') waterText = 'Su';
                        else if (lang === 'en') waterText = 'Water';
                        return `${waterText} ${amount} ${unit}`;
                    }
                },
                {
                    regex: /^Канализация(?:\s*\(авто\))?\s+([\d.]+)\s*м³$/i,
                    serviceKey: 'meter_sewerage',
                    unitKey: 'user_unit_m3',
                    format: (amount, service, unit) => {
                        // Перевод, если ключа нет — fallback на RU
                        let text = service || 'Канализация';
                        if (!service) {
                            if (lang === 'az') text = 'Kanalizasiya';
                            else if (lang === 'en') text = 'Sewerage';
                        }
                        return `${text} ${amount} ${unit}`;
                    }
                },
                {
                    regex: /^Газ\s+([\d.]+)\s*м³$/i,
                    serviceKey: 'meter_gas',
                    unitKey: 'user_unit_m3',
                    format: (amount, service, unit) => `${service} ${amount} ${unit}`
                },
                {
                    regex: /^Горячая\s+вода\s+([\d.]+)\s*м³$/i,
                    serviceKey: 'meter_hot_water',
                    unitKey: 'user_unit_m3',
                    format: (amount, service, unit) => `${service} ${amount} ${unit}`
                }
            ];
            
            for (const pattern of patterns) {
                const match = description.match(pattern.regex);
                if (match) {
                    const amount = match[1];
                    const service = window.i18n?.translate?.(pattern.serviceKey, lang) || description.split(' ')[0];
                    const unit = window.i18n?.translate?.(pattern.unitKey, lang) || match[0].split(amount)[1].trim();
                    return pattern.format(amount, service, unit);
            }
            }
            
            // Если не найден паттерн, возвращаем оригинал
            return description;
        }

        function extractConsumption(description, lang) {
            if (!description) {
                return { label: '—', consumed: '—', serviceKey: '', qty: '', unitKey: '' };
            }

            const isSewerageLine = /^(?:meter_sewerage\b|Канализация(?:\s*\(авто\))?\b)/i.test(String(description).trim());

            const keyPattern = /^(meter_[a-z_]+)\s+([\d.]+)\s*(.*)$/i;
            const keyMatch = description.match(keyPattern);
            if (keyMatch) {
                const key = keyMatch[1];
                const qty = keyMatch[2];
                const unitRaw = keyMatch[3] ? keyMatch[3].trim() : '';
                const label = window.i18n?.translate?.(key, lang) || key;
                if (key === 'meter_sewerage') {
                    return { label, consumed: '—', serviceKey: key, qty: '', unitKey: '' };
                }
                const unit = unitRaw || '';
                let unitKey = '';
                if (/квт/i.test(unitRaw)) unitKey = 'user_unit_kwh';
                else if (/м³|m3|m³/i.test(unitRaw)) unitKey = 'user_unit_m3';
                return { label, consumed: `${qty} ${unit}`.trim(), serviceKey: key, qty, unitKey };
            }

            const patterns = [
                {
                    regex: /^Электричество\s+([\d.]+)\s*кВт·ч$/i,
                    serviceKey: 'meter_electricity',
                    unitKey: 'user_unit_kwh'
                },
                {
                    regex: /^Вода\s+([\d.]+)\s*м³$/i,
                    serviceKey: 'meter_cold_water',
                    unitKey: 'user_unit_m3'
                },
                {
                    regex: /^Канализация(?:\s*\(авто\))?\s+([\d.]+)\s*м³$/i,
                    serviceKey: 'meter_sewerage',
                    unitKey: 'user_unit_m3'
                },
                {
                    regex: /^Газ\s+([\d.]+)\s*м³$/i,
                    serviceKey: 'meter_gas',
                    unitKey: 'user_unit_m3'
                },
                {
                    regex: /^Горячая\s+вода\s+([\d.]+)\s*м³$/i,
                    serviceKey: 'meter_hot_water',
                    unitKey: 'user_unit_m3'
                }
            ];

            for (const pattern of patterns) {
                const match = description.match(pattern.regex);
                if (match) {
                    const amount = match[1];
                    const label = window.i18n?.translate?.(pattern.serviceKey, lang) || description.split(' ')[0];
                    if (pattern.serviceKey === 'meter_sewerage' || isSewerageLine) {
                        return { label, consumed: '—', serviceKey: pattern.serviceKey, qty: '', unitKey: '' };
                    }
                    const unit = window.i18n?.translate?.(pattern.unitKey, lang) || match[0].split(amount)[1].trim();
                    return { label, consumed: `${amount} ${unit}`.trim(), serviceKey: pattern.serviceKey, qty: amount, unitKey: pattern.unitKey };
                }
            }

            if (isSewerageLine) {
                const label = window.i18n?.translate?.('meter_sewerage', lang) || 'Канализация';
                return { label, consumed: '—', serviceKey: 'meter_sewerage', qty: '', unitKey: '' };
            }

            const fallbackSplit = description.match(/^(.+?)\s+([\d.]+)\s*(.*)$/);
            if (fallbackSplit) {
                const label = fallbackSplit[1].trim();
                const qty = fallbackSplit[2].trim();
                const unit = fallbackSplit[3].trim();
                return { label, consumed: `${qty} ${unit}`.trim(), serviceKey: '', qty, unitKey: '' };
            }

            return { label: description, consumed: '—', serviceKey: '', qty: '', unitKey: '' };
        }

        // Render invoice lines
        function renderInvoiceLines(lines, total) {
            const tbody = document.getElementById('invoiceItemsBody');
            if (!tbody) return;
            
            if (lines.length === 0) {
                const lang = localStorage.getItem('language') || 'ru';
                const emptyText = window.i18n?.translate?.('user_invoice_items_empty', lang) || 'Позиции отсутствуют';
                tbody.innerHTML = `<tr><td colspan="6" class="text-center text-muted">${emptyText}</td></tr>`;
                return;
            }
            
            const lang = localStorage.getItem('language') || 'ru';
            tbody.innerHTML = lines.map(line => {
                const parsed = extractConsumption(line.description, lang);
                const translatedDescription = parsed.label;
                const totalAmount = Number(line.amount_total || 0);
                const paidAmount = Math.max(0, Number(line.paid_amount || 0));
                const paymentStatus = line.payment_status || 'Не оплачена';
                const ratio = totalAmount > 0 ? Math.min(100, Math.max(0, (paidAmount / totalAmount) * 100)) : 0;
                let statusClass = 'payment-status-unpaid';
                if (paymentStatus === 'Оплачена') statusClass = 'payment-status-paid';
                else if (paymentStatus === 'Частично') statusClass = 'payment-status-partial';
                return `
                <tr>
                    <td data-original-description="${line.description || ''}" data-service-key="${parsed.serviceKey || ''}">${translatedDescription}</td>
                    <td data-consumed-qty="${parsed.qty || ''}" data-consumed-unit-key="${parsed.unitKey || ''}">${parsed.consumed}</td>
                    <td>${formatCurrency(line.amount_net)}</td>
                    <td>${formatCurrency(line.amount_vat)}</td>
                    <td class="total-value">${formatCurrency(line.amount_total)}</td>
                    <td>
                        <div class="payment-status-card ${statusClass}">
                            <div class="payment-status-head">${paymentStatus}</div>
                            <div class="payment-status-meta">Оплачено ${formatCurrency(paidAmount)} из ${formatCurrency(totalAmount)}</div>
                            <div class="payment-status-track"><span style="width:${ratio.toFixed(2)}%"></span></div>
                        </div>
                    </td>
                </tr>
                `;
            }).join('') + `
                <tr class="total-row">
                    <td colspan="4" data-i18n="user_invoice_items_total_row">Итого к оплате</td>
                    <td class="total-value">${formatCurrency(total)}</td>
                    <td></td>
                </tr>
            `;
        }

        // Get CSS class for status
        function getStatusClass(status) {
            const statusMap = {
                'PAID': 'paid',
                'ISSUED': 'issued',
                'PARTIAL': 'partial',
                'DRAFT': 'draft',
                'OVERPAID': 'overpaid',
                'CANCELED': 'canceled'
            };
            return statusMap[status] || '';
        }

        // Format currency
        function formatCurrency(amount) {
            const lang = localStorage.getItem('language') || 'ru';
            const locale = lang === 'az' ? 'az-AZ' : lang === 'en' ? 'en-US' : 'ru-RU';
            return new Intl.NumberFormat(locale, {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(amount);
        }

        function formatDateTime(value) {
            if (!value) return '—';
            try {
                const lang = localStorage.getItem('language') || 'ru';
                const locale = lang === 'az' ? 'az-AZ' : lang === 'en' ? 'en-US' : 'ru-RU';
                const dt = new Date(value);
                return dt.toLocaleString(locale, {
                    timeZone: 'Asia/Baku',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return '—';
            }
        }

        // Load data when page is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadInvoiceData);
        } else {
            setTimeout(loadInvoiceData, 100);
        }
    })();
</script>
