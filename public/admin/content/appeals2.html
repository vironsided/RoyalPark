<link rel="stylesheet" href="/css/appeals2.css">
<style>
    /* Horizontal pagination buttons */
    .pagination-controls {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .pagination-pages {
        display: flex;
        gap: 8px;
        align-items: center;
    }
</style>

<div class="dashboard-content">
    <div>
        <div class="card">
            <div class="card-body">
                <div class="appeals-header">
                    <h4 class="card-title mb-0">Обращения жителей</h4>
                    <div class="appeals-filter-group">
                        <span>Статус:</span>
                        <select id="appealsStatusFilter" class="appeals-filter-select">
                            <option value="all">Все</option>
                            <option value="UNREAD">Не прочитано</option>
                            <option value="READ">Прочитано</option>
                        </select>
                    </div>
                </div>

                <div class="table-responsive">
                    <table class="table align-middle">
                        <thead>
                            <tr>
                                <th>Создано</th>
                                <th>Блок</th>
                                <th>Дом</th>
                                <th>Житель</th>
                                <th>Телефон</th>
                                <th>E-mail</th>
                                <th>Статус</th>
                                <th class="text-end">Действия</th>
                            </tr>
                        </thead>
                        <tbody id="appealsTableBody">
                            <tr>
                                <td colspan="8" class="text-center">Загрузка данных...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>



                <div class="appeals-empty" id="appealsEmptyState" style="display: none;">
                    <i class="bi bi-inbox" style="font-size:2rem;"></i>
                    <p class="mt-3 mb-0">Обращений нет</p>
                </div>
            </div>
            <!-- Pagination -->
            <div class="table-pagination">
                <div class="pagination-controls" id="appealPaginationControls">
                    <button class="btn-pagination" onclick="goToAppealPage('prev')" disabled id="appealPrevBtn">
                        <i class="bi bi-chevron-double-left"></i>
                    </button>
                    <div id="appealPageButtons" class="pagination-pages"></div>
                    <button class="btn-pagination" onclick="goToAppealPage('next')" disabled id="appealNextBtn">
                        <i class="bi bi-chevron-double-right"></i>
                    </button>
                </div>
                <div class="pagination-info">
                    <span>Стр. <span id="appealCurrentPage">1</span> из <span id="appealTotalPages">1</span> · всего
                        <span id="appealTotalItems">0</span></span>
                </div>
                <div class="pagination-per-page">
                    <span>На</span>
                    <span>странице:</span>
                    <div class="custom-pag-select" id="customAppealItemsPerPage">
                        <select id="appealItemsPerPage" onchange="changeAppealItemsPerPage()" style="display: none;">
                            <option value="10">10</option>
                            <option value="25" selected>25</option>
                            <option value="50">50</option>
                            <option value="100">100</option>
                        </select>
                        <div class="select-btn">
                            <span class="select-text">25</span>
                            <span class="arrow">▾</span>
                        </div>
                        <div class="select-options" style="background: rgba(36, 40, 49, 0.95) !important">
                            <div class="select-option" data-value="10">10</div>
                            <div class="select-option selected" data-value="25">25</div>
                            <div class="select-option" data-value="50">50</div>
                            <div class="select-option" data-value="100">100</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="appeal-modal-overlay" id="appealModal">
    <div class="appeal-modal">
        <div class="appeal-modal-header">
            <h5 class="mb-0">Обращение</h5>
            <button type="button" class="btn-close btn-close-white" id="appealModalClose"></button>
        </div>
        <div class="appeal-modal-body">
            <div class="appeal-info-row">
                <span>Дом</span>
                <strong id="modalApartment">—</strong>
            </div>
            <div class="appeal-info-row">
                <span>Житель</span>
                <strong id="modalResident">—</strong>
            </div>
            <div class="appeal-info-row">
                <span>Контакты</span>
                <strong id="modalContacts">— / —</strong>
            </div>
            <div>
                <small class="text-muted text-uppercase">Описание</small>
                <p class="mb-0 mt-1" id="modalDescription">—</p>
            </div>
        </div>
        <div class="appeal-modal-footer">
            <button class="btn btn-outline-light" id="appealModalDismiss">Закрыть</button>
        </div>
    </div>
</div>

<!-- Модальное окно подтверждения удаления -->
<div class="appeal-modal-overlay" id="deleteConfirmModal" style="display: none;">
    <div class="appeal-modal" style="width: min(400px, 90vw);">
        <div class="appeal-modal-header">
            <h5 class="mb-0">Подтвердите действие</h5>
            <button type="button" class="btn-close btn-close-white" id="deleteConfirmModalClose"></button>
        </div>
        <div class="appeal-modal-body">
            <p class="mb-0" id="deleteConfirmMessage">Вы уверены, что хотите удалить это обращение?</p>
        </div>
        <div class="appeal-modal-footer" style="justify-content: flex-end; gap: 0.75rem;">
            <button class="btn btn-outline-light" id="deleteConfirmCancel">Отмена</button>
            <button class="btn btn-primary" id="deleteConfirmOk">OK</button>
        </div>
    </div>
</div>

<script>
    (function () {
        'use strict';

        const API_BASE = 'http://localhost:8000';
        const state = {
            notifications: [],
            currentNotification: null,
            notificationOpenedFromUrl: false // Флаг, что модальное окно уже было открыто из URL
        };

        // Pagination state
        let paginationState = {
            currentPage: 1,
            itemsPerPage: 25,
            totalItems: 0,
            totalPages: 1
        };

        const statusStyles = {
            READ: { text: 'прочитано', className: 'bg-success' },
            UNREAD: { text: 'не прочитано', className: 'bg-warning text-dark' }
        };

        let tableBody, emptyState, statusSelect, modalOverlay;
        let modalResident, modalApartment, modalContacts, modalDescription;
        let deleteConfirmModal, deleteConfirmMessage, deleteConfirmOk, deleteConfirmCancel, deleteConfirmClose;
        let pendingDeleteId = null;

        function cacheDom() {
            tableBody = document.getElementById('appealsTableBody');
            emptyState = document.getElementById('appealsEmptyState');
            statusSelect = document.getElementById('appealsStatusFilter');
            modalOverlay = document.getElementById('appealModal');
            modalResident = document.getElementById('modalResident');
            modalApartment = document.getElementById('modalApartment');
            modalContacts = document.getElementById('modalContacts');
            modalDescription = document.getElementById('modalDescription');

            // Элементы модального окна подтверждения удаления
            deleteConfirmModal = document.getElementById('deleteConfirmModal');
            deleteConfirmMessage = document.getElementById('deleteConfirmMessage');
            deleteConfirmOk = document.getElementById('deleteConfirmOk');
            deleteConfirmCancel = document.getElementById('deleteConfirmCancel');
            deleteConfirmClose = document.getElementById('deleteConfirmModalClose');
        }

        async function loadNotifications() {
            try {
                const statusValue = statusSelect?.value || 'all';
                const statusParam = statusValue !== 'all' ? `&status=${statusValue}` : '';
                // Используем /notifications/json с пагинацией
                const url = `${API_BASE}/notifications/json?page=${paginationState.currentPage}&per_page=${paginationState.itemsPerPage}${statusParam}`;

                console.log('Loading notifications from:', url);
                const response = await fetch(url);

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        console.log('Not authorized, using public endpoint');
                        // Уже используем публичный endpoint
                        throw new Error('Unauthorized');
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Notifications data received:', data);

                // Handle paginated response
                if (data.notifications && data.pagination) {
                    state.notifications = data.notifications || [];

                    // Update pagination state
                    paginationState.totalItems = data.pagination.total || 0;
                    paginationState.totalPages = data.pagination.last_page || 1;
                    paginationState.currentPage = data.pagination.page || 1;
                } else {
                    // Fallback for non-paginated response (backward compatibility)
                    state.notifications = data.notifications || [];
                    paginationState.totalItems = state.notifications.length;
                    paginationState.totalPages = 1;
                    paginationState.currentPage = 1;
                }

                renderTable();
                updatePaginationUI();

                // Возвращаем промис для возможности ожидания
                return Promise.resolve();
            } catch (error) {
                console.error('Error loading notifications:', error);
                if (typeof showError === 'function') {
                    showError('Ошибка загрузки обращений: ' + error.message);
                }
                state.notifications = [];
                paginationState.totalItems = 0;
                paginationState.totalPages = 1;
                paginationState.currentPage = 1;
                renderTable();
                updatePaginationUI();
                return Promise.reject(error);
            }
        }

        function renderTable() {
            if (!tableBody) {
                console.error('Table body not found!');
                return;
            }

            const items = state.notifications;

            if (!items.length) {
                tableBody.innerHTML = '';
                if (emptyState) emptyState.style.display = 'block';
                return;
            }

            if (emptyState) emptyState.style.display = 'none';

            tableBody.innerHTML = items.map(notif => {
                const status = statusStyles[notif.status] || statusStyles.UNREAD;
                const block = notif.block_name || '—';
                const home = notif.unit_number || '—';
                const resident = notif.user_full_name || '—';
                const phone = notif.user_phone || '—';
                const email = notif.user_email || '—';

                // Форматируем дату как на фотографии: отдельно дата и время
                const dateStr = formatDateTime(notif.created_at);
                const [datePart, timePart] = dateStr.split(', ');

                return `
                <tr>
                    <td>
                        <div style="font-weight: 500;">${datePart || '—'}</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 2px;">${timePart || ''}</div>
                    </td>
                    <td style="text-align: center; font-weight: 500;">${block}</td>
                    <td style="text-align: center; font-weight: 500;">${home}</td>
                    <td style="font-weight: 500;">${resident}</td>
                    <td>${phone}</td>
                    <td>${email}</td>
                    <td style="text-align: center;">
                        <span class="appeals-status-badge ${status.className}">${status.text}</span>
                    </td>
                    <td style="text-align: right; white-space: nowrap;">
                        <button class="btn btn-outline-primary btn-sm" data-action="view" data-id="${notif.id}" style="margin-right: 0.5rem;">
                            Просмотр
                        </button>
                        <button class="btn btn-outline-danger btn-sm" data-action="delete" data-id="${notif.id}">
                            Удалить
                        </button>
                    </td>
                </tr>
            `;
            }).join('');
        }

        async function viewNotification(id) {
            try {
                console.log('Opening notification modal for ID:', id);
                // Используем /notifications/{id}/json вместо /api/notifications/{id}/public
                const url = `${API_BASE}/notifications/${id}/json`;
                console.log('Fetching from:', url);
                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const notif = await response.json();
                console.log('Notification data received:', notif);
                state.currentNotification = notif;

                // Обрабатываем данные - проверяем разные форматы ответа
                let block = '—';
                let home = '—';
                let residentName = '—';
                let phone = '—';
                let email = '—';
                let message = '—';

                // Проверяем формат с вложенными объектами (старый формат)
                if (notif.resident) {
                    block = notif.resident.block || '—';
                    home = notif.resident.unit_number || '—';
                } else {
                    // Новый формат с плоскими полями
                    block = notif.block_name || '—';
                    home = notif.unit_number || '—';
                }

                if (notif.user) {
                    residentName = notif.user.full_name || '—';
                    phone = notif.user.phone || '—';
                    email = notif.user.email || '—';
                } else {
                    residentName = notif.user_full_name || '—';
                    phone = notif.user_phone || '—';
                    email = notif.user_email || '—';
                }

                message = notif.message || '—';

                // Заполняем модальное окно
                if (modalApartment) {
                    modalApartment.textContent = `${block} / ${home}`;
                }
                if (modalResident) {
                    modalResident.textContent = residentName;
                }
                if (modalContacts) {
                    modalContacts.textContent = `${phone} / ${email}`;
                }
                if (modalDescription) {
                    modalDescription.textContent = message;
                }

                // Показываем модальное окно
                if (modalOverlay) {
                    console.log('Showing modal overlay');
                    modalOverlay.classList.add('show');
                    // Убеждаемся, что модальное окно видимо
                    modalOverlay.style.display = 'flex';
                } else {
                    console.error('Modal overlay not found! Attempting to cache DOM again...');
                    cacheDom();
                    if (modalOverlay) {
                        console.log('Modal overlay found after re-caching');
                        modalOverlay.classList.add('show');
                        modalOverlay.style.display = 'flex';
                    } else {
                        console.error('Modal overlay still not found!');
                    }
                }

                // Очищаем параметр id из URL после открытия модального окна
                clearNotificationIdFromUrl();

                // Перезагружаем список, чтобы обновить статус
                await loadNotifications();
            } catch (error) {
                console.error('Error loading notification:', error);
                if (typeof showError === 'function') {
                    showError('Ошибка загрузки обращения: ' + error.message);
                } else {
                    alert('Ошибка загрузки обращения: ' + error.message);
                }
            }
        }

        function showDeleteConfirm(id) {
            pendingDeleteId = id;
            if (deleteConfirmModal) {
                deleteConfirmModal.style.display = 'flex';
            }
        }

        function hideDeleteConfirm() {
            pendingDeleteId = null;
            if (deleteConfirmModal) {
                deleteConfirmModal.style.display = 'none';
            }
        }

        async function deleteNotification(id) {
            try {
                // Используем /notifications/{id}/json вместо /api/notifications/{id}/public
                const url = `${API_BASE}/notifications/${id}/json`;
                const response = await fetch(url, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                if (typeof showSuccess === 'function') {
                    showSuccess('Обращение успешно удалено!');
                }

                hideDeleteConfirm();
                // Reload current page to see updated list
                await loadNotifications();

                // If current page is now empty (beyond last page), go to last page
                if (paginationState.currentPage > paginationState.totalPages && paginationState.totalPages > 0) {
                    paginationState.currentPage = paginationState.totalPages;
                    await loadNotifications();
                }
            } catch (error) {
                console.error('Error deleting notification:', error);
                if (typeof showError === 'function') {
                    showError('Ошибка удаления обращения: ' + error.message);
                }
                hideDeleteConfirm();
            }
        }

        function closeModal() {
            if (modalOverlay) {
                modalOverlay.classList.remove('show');
                modalOverlay.style.display = 'none';
            }
        }

        function formatDateTime(value) {
            if (!value) return '—';
            const date = new Date(value);
            return date.toLocaleString('ru-RU', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function bindEvents() {
            // Обработчик change уже добавлен в initAppealsPage

            if (tableBody) {
                tableBody.addEventListener('click', (event) => {
                    const viewBtn = event.target.closest('[data-action="view"]');
                    const deleteBtn = event.target.closest('[data-action="delete"]');
                    if (viewBtn) {
                        const id = parseInt(viewBtn.dataset.id);
                        viewNotification(id);
                    } else if (deleteBtn) {
                        const id = parseInt(deleteBtn.dataset.id);
                        showDeleteConfirm(id);
                    }
                });
            }

            const closeBtn = document.getElementById('appealModalClose');
            const dismissBtn = document.getElementById('appealModalDismiss');
            if (closeBtn) closeBtn.addEventListener('click', closeModal);
            if (dismissBtn) dismissBtn.addEventListener('click', closeModal);
            if (modalOverlay) {
                modalOverlay.addEventListener('click', (event) => {
                    if (event.target === modalOverlay) closeModal();
                });
            }

            // Обработчики для модального окна подтверждения удаления
            if (deleteConfirmOk) {
                deleteConfirmOk.addEventListener('click', () => {
                    if (pendingDeleteId !== null) {
                        deleteNotification(pendingDeleteId);
                    }
                });
            }
            if (deleteConfirmCancel) {
                deleteConfirmCancel.addEventListener('click', hideDeleteConfirm);
            }
            if (deleteConfirmClose) {
                deleteConfirmClose.addEventListener('click', hideDeleteConfirm);
            }
            if (deleteConfirmModal) {
                deleteConfirmModal.addEventListener('click', (event) => {
                    if (event.target === deleteConfirmModal) {
                        hideDeleteConfirm();
                    }
                });
            }
        }

        function applyDarkThemeToSelect() {
            const selectElement = document.getElementById('appealsStatusFilter');
            if (selectElement) {
                // Применить темные стили к select
                selectElement.style.setProperty('background-color', 'rgba(31, 35, 48, 0.9)', 'important');
                selectElement.style.setProperty('background', 'rgba(31, 35, 48, 0.9)', 'important');
                selectElement.style.setProperty('color', '#ffffff', 'important');
                selectElement.style.setProperty('border-color', 'rgba(102, 126, 234, 0.5)', 'important');

                // Применить темные стили к option элементам
                const options = selectElement.querySelectorAll('option');
                options.forEach(option => {
                    option.style.setProperty('background', '#1f2330', 'important');
                    option.style.setProperty('background-color', '#1f2330', 'important');
                    option.style.setProperty('color', '#ffffff', 'important');
                });
            }

            // Инъекция CSS для темных option элементов
            const styleId = 'appeals-select-dark-theme';
            if (!document.getElementById(styleId)) {
                const style = document.createElement('style');
                style.id = styleId;
                style.textContent = `
                #appealsStatusFilter {
                    background-color: rgba(31, 35, 48, 0.9) !important;
                    background: rgba(31, 35, 48, 0.9) !important;
                    color: #ffffff !important;
                }
                #appealsStatusFilter option {
                    background: #1f2330 !important;
                    background-color: #1f2330 !important;
                    color: #ffffff !important;
                }
                #appealsStatusFilter option:checked {
                    background: #667eea !important;
                    background-color: #667eea !important;
                    color: #ffffff !important;
                }
            `;
                document.head.appendChild(style);
            }
        }

        function getNotificationIdFromUrl() {
            // Если модальное окно уже было открыто из URL, не открываем снова
            if (state.notificationOpenedFromUrl) {
                return null;
            }

            // Сначала проверяем глобальную переменную, установленную spa-router
            if (window.__currentNotificationId) {
                return window.__currentNotificationId;
            }

            // Проверяем hash для SPA роутера
            const hash = window.location.hash;
            if (hash.includes('?')) {
                const hashParts = hash.split('?');
                if (hashParts.length > 1) {
                    const params = new URLSearchParams(hashParts[1]);
                    const id = params.get('id');
                    if (id) return parseInt(id);
                }
            }

            // Проверяем обычный query string
            const urlParams = new URLSearchParams(window.location.search);
            const id = urlParams.get('id');
            if (id) return parseInt(id);

            return null;
        }

        function clearNotificationIdFromUrl() {
            // Очищаем глобальную переменную
            if (window.__currentNotificationId) {
                delete window.__currentNotificationId;
            }

            // Очищаем параметр id из hash
            const hash = window.location.hash;
            if (hash.includes('?')) {
                const hashParts = hash.split('?');
                const baseRoute = hashParts[0];
                const params = new URLSearchParams(hashParts[1]);
                params.delete('id');

                // Формируем новый hash без параметра id
                const newHash = params.toString() ? `${baseRoute}?${params.toString()}` : baseRoute;

                // Обновляем URL без перезагрузки страницы
                if (window.spaRouter) {
                    // Используем navigate без параметра id
                    window.spaRouter.navigate(baseRoute.slice(1)); // Убираем #
                } else {
                    window.location.hash = baseRoute;
                }
            }

            // Устанавливаем флаг, что модальное окно было открыто
            state.notificationOpenedFromUrl = true;
        }

        // Pagination Functions
        function buildAppealPageList(current, total) {
            if (total <= 5) {
                return Array.from({ length: total }, (_, i) => i + 1);
            }

            const pages = new Set([1, total]);

            if (current <= 3) {
                [2, 3, 4, 5].forEach(p => pages.add(p));
            } else if (current >= total - 2) {
                [total - 1, total - 2, total - 3, total - 4].forEach(p => pages.add(p));
            } else {
                [current - 2, current - 1, current, current + 1, current + 2].forEach(p => pages.add(p));
            }

            const sorted = Array.from(pages).filter(p => p >= 1 && p <= total).sort((a, b) => a - b);
            const result = [];

            for (let i = 0; i < sorted.length; i++) {
                const page = sorted[i];
                result.push(page);
                const next = sorted[i + 1];
                if (next && next - page > 1) {
                    result.push('dots');
                }
            }

            return result;
        }

        function updatePaginationUI() {
            const currentPageEl = document.getElementById('appealCurrentPage');
            const totalPagesEl = document.getElementById('appealTotalPages');
            const totalItemsEl = document.getElementById('appealTotalItems');
            const prevBtn = document.getElementById('appealPrevBtn');
            const nextBtn = document.getElementById('appealNextBtn');
            const pagesContainer = document.getElementById('appealPageButtons');

            if (currentPageEl) currentPageEl.textContent = paginationState.currentPage;
            if (totalPagesEl) totalPagesEl.textContent = paginationState.totalPages;
            if (totalItemsEl) totalItemsEl.textContent = paginationState.totalItems;
            if (prevBtn) prevBtn.disabled = paginationState.currentPage <= 1;
            if (nextBtn) nextBtn.disabled = paginationState.currentPage >= paginationState.totalPages;

            if (!pagesContainer) return;
            pagesContainer.innerHTML = '';

            const pages = buildAppealPageList(paginationState.currentPage, paginationState.totalPages);
            pages.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn-pagination';

                if (p === 'dots') {
                    btn.textContent = '...';
                    btn.disabled = true;
                    btn.classList.add('dots');
                } else {
                    btn.textContent = p;
                    if (p > paginationState.totalPages) {
                        btn.disabled = true;
                    } else {
                        btn.onclick = () => {
                            if (p !== paginationState.currentPage) {
                                goToAppealPage(p);
                            }
                        };
                    }
                    if (p === paginationState.currentPage) {
                        btn.classList.add('active');
                        btn.setAttribute('aria-current', 'page');
                    }
                }

                pagesContainer.appendChild(btn);
            });
        }

        window.goToAppealPage = function (page) {
            if (page === 'prev') {
                if (paginationState.currentPage > 1) {
                    paginationState.currentPage--;
                    loadNotifications();
                }
            } else if (page === 'next') {
                if (paginationState.currentPage < paginationState.totalPages) {
                    paginationState.currentPage++;
                    loadNotifications();
                }
            } else if (typeof page === 'number') {
                paginationState.currentPage = page;
                loadNotifications();
            }
        };

        window.changeAppealItemsPerPage = function () {
            const select = document.getElementById('appealItemsPerPage');
            if (select) {
                paginationState.itemsPerPage = parseInt(select.value);
                paginationState.currentPage = 1;
                loadNotifications();
                updateCustomAppealPaginationDropdown();
            }
        };

        function updateCustomAppealPaginationDropdown() {
            const select = document.getElementById('appealItemsPerPage');
            const customSelect = document.getElementById('customAppealItemsPerPage');
            if (!select || !customSelect) return;

            const value = select.value;
            const selectText = customSelect.querySelector('.select-text');
            const options = customSelect.querySelectorAll('.select-option');

            if (selectText) selectText.textContent = value;
            options.forEach(opt => {
                opt.classList.remove('selected');
                if (opt.getAttribute('data-value') === value) {
                    opt.classList.add('selected');
                }
            });
        }

        function initCustomAppealPaginationDropdown() {
            const customSelect = document.getElementById('customAppealItemsPerPage');
            if (!customSelect) return;

            const selectBtn = customSelect.querySelector('.select-btn');
            const selectOptions = customSelect.querySelector('.select-options');

            if (!selectBtn || !selectOptions) {
                console.warn('Custom pagination select elements not found');
                return;
            }

            const options = selectOptions.querySelectorAll('.select-option');

            // Удаляем старый обработчик, если он существует
            if (selectBtn._appealClickHandler) {
                selectBtn.removeEventListener('click', selectBtn._appealClickHandler);
            }

            selectBtn._appealClickHandler = function (e) {
                e.stopPropagation();
                e.preventDefault();
                customSelect.classList.toggle('open');
            };

            selectBtn.addEventListener('click', selectBtn._appealClickHandler);

            options.forEach(opt => {
                // Удаляем старый обработчик, если он существует
                if (opt._appealOptionClickHandler) {
                    opt.removeEventListener('click', opt._appealOptionClickHandler);
                }

                opt._appealOptionClickHandler = function (e) {
                    e.stopPropagation();
                    const value = this.getAttribute('data-value');
                    const select = document.getElementById('appealItemsPerPage');
                    if (select) {
                        select.value = value;
                        changeAppealItemsPerPage();
                    }
                    customSelect.classList.remove('open');
                };

                opt.addEventListener('click', opt._appealOptionClickHandler);
            });

            // Удаляем старый обработчик клика на документе, если он существует
            if (window._appealPaginationClickHandler) {
                document.removeEventListener('click', window._appealPaginationClickHandler);
            }

            window._appealPaginationClickHandler = function (e) {
                if (!customSelect.contains(e.target)) {
                    customSelect.classList.remove('open');
                }
            };

            document.addEventListener('click', window._appealPaginationClickHandler);

            updateCustomAppealPaginationDropdown();
        }

        function initAppealsPage() {
            console.log('Initializing appeals2 page...');

            // Сбрасываем флаг при каждой инициализации страницы
            // Это позволяет открывать модальное окно при переходе с параметром id
            state.notificationOpenedFromUrl = false;

            cacheDom();
            bindEvents();
            initCustomAppealPaginationDropdown();

            // Применить темные стили к выпадающему списку
            applyDarkThemeToSelect();

            // Применить стили при открытии select
            if (statusSelect) {
                statusSelect.addEventListener('mousedown', function () {
                    setTimeout(applyDarkThemeToSelect, 10);
                });
                statusSelect.addEventListener('focus', function () {
                    setTimeout(applyDarkThemeToSelect, 10);
                });
                statusSelect.addEventListener('change', function () {
                    setTimeout(applyDarkThemeToSelect, 10);
                    // Reset to first page when filter changes
                    paginationState.currentPage = 1;
                    loadNotifications();
                });
            }

            // Проверяем, есть ли id в URL - если есть, значит это переход с уведомления
            const notificationId = getNotificationIdFromUrl();
            if (notificationId) {
                console.log('Found notification ID in URL:', notificationId);
                // Загружаем список, затем открываем нужное уведомление
                loadNotifications().then(() => {
                    // Увеличиваем задержку, чтобы DOM точно был готов
                    setTimeout(() => {
                        console.log('Attempting to open notification:', notificationId);
                        // Повторно кешируем DOM элементы перед открытием
                        cacheDom();
                        if (modalOverlay) {
                            viewNotification(notificationId);
                        } else {
                            console.error('Modal overlay not found, retrying...');
                            setTimeout(() => {
                                cacheDom();
                                if (modalOverlay) {
                                    viewNotification(notificationId);
                                }
                            }, 200);
                        }
                    }, 500);
                }).catch(err => {
                    console.error('Error loading notifications:', err);
                });
            } else {
                loadNotifications();
            }

            // Повторно применить стили через небольшую задержку
            setTimeout(applyDarkThemeToSelect, 100);
            setTimeout(applyDarkThemeToSelect, 500);
        }

        // Удаляем старый обработчик, если он существует
        if (window._appeals2ContentLoadedHandler) {
            window.removeEventListener('spa:contentLoaded', window._appeals2ContentLoadedHandler);
        }

        window._appeals2ContentLoadedHandler = function (e) {
            console.log('SPA content loaded event:', e.detail);
            const route = e.detail?.route || window.location.hash.split('?')[0].slice(1);
            console.log('Current route:', route);
            if (!route || route === '/appeals2' || route.startsWith('/appeals2')) {
                console.log('Loading appeals2 from spa:contentLoaded');
                // Инициализируем страницу - она сама проверит URL на наличие id
                setTimeout(() => {
                    initAppealsPage();
                }, 100);
            }
        };

        window.addEventListener('spa:contentLoaded', window._appeals2ContentLoadedHandler);

        // Загрузка при первой загрузке (если не через SPA)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initAppealsPage);
        } else {
            initAppealsPage();
        }

    })();
</script>